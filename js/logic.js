import { Stems, Branches, HourByDayStem, NaYin, FiveEl, Yang, ShenShaRules } from './data.js';

export function parseGZ(s){ if(!s) return null; const v=s.trim().replace(/\s+/g,""); if(v.length!==2) return null; const g=v[0], z=v[1]; if(!Stems.includes(g)||!Branches.includes(z)) return null; return g+z; }
export function hourToBranch(h){ if(h>=23||h<1) return "子"; if(h>=1&&h<3) return "丑"; if(h>=3&&h<5) return "寅"; if(h>=5&&h<7) return "卯"; if(h>=7&&h<9) return "辰"; if(h>=9&&h<11) return "巳"; if(h>=11&&h<13) return "午"; if(h>=13&&h<15) return "未"; if(h>=15&&h<17) return "申"; if(h>=17&&h<19) return "酉"; if(h>=19&&h<21) return "戌"; if(h>=21&&h<23) return "亥"; return ""; }
export function hourPillar(dayStem, hourBranch){ const a=HourByDayStem[dayStem]; const i=Branches.indexOf(hourBranch); return (a&&i>=0)?a[i]:null; }
export function tenGod(dayStem, otherStem){ const elA=FiveEl[dayStem], elB=FiveEl[otherStem]; const same=(Yang.has(dayStem)===Yang.has(otherStem)); const cycle={"木":"火","火":"土","土":"金","金":"水","水":"木"}; const control={"木":"土","土":"水","水":"火","火":"金","金":"木"}; if(elA===elB) return same?"比肩":"劫財"; if(cycle[elA]===elB) return same?"食神":"傷官"; if(cycle[elB]===elA) return same?"正印":"偏印"; if(control[elA]===elB) return same?"偏財":"正財"; if(control[elB]===elA) return same?"七殺":"正官"; return ""; }
export function nayin(gz){ return NaYin[gz]||""; }
export function nayinEl(n){ if(!n) return "未知"; if(n.includes("金")) return "金"; if(n.includes("木")) return "木"; if(n.includes("水")) return "水"; if(n.includes("火")) return "火"; if(n.includes("土")) return "土"; return "未知"; }
export function computeFiveElementStrength(pillarsObj, nayins){ const weight={金:0,木:0,水:0,火:0,土:0}; const detail=[]; for(const k of ["Y","M","D","H"]){ const gz=pillarsObj[k]; const stem=gz[0]; const el=FiveEl[stem]; weight[el]+=1; detail.push({pillar:k,type:"stem",el,amount:1,from:gz}); const ny=nayins[k]; const nyEl=nayinEl(ny); if(weight[nyEl]!=null){ weight[nyEl]+=0.5; detail.push({pillar:k,type:"nayin",el:nyEl,amount:0.5,from:ny}); } } const total=Object.values(weight).reduce((a,b)=>a+b,0); const avg=total/5; const status={}; for(const el of Object.keys(weight)){ const v=weight[el]; status[el]= v>=avg+0.8?"旺":(v<=avg-0.8?"弱":"平"); } return { weight, detail, status, total, avg }; }
export function buildStory(who, pillar, tg, ssCats, ny, name, elStatus){ const el=nayinEl(ny); const army={"年":"家族兵團","月":"成長兵團","日":"本我兵團","時":"未來兵團"}[who]; const statusTxt=elStatus&&el!=="未知"?`（此元素偏${elStatus==="平"?"勢衡":"呈"+elStatus}）`:""; const toneMap={"金":"重紀律與決斷，擅割裂低效環節。","木":"重生長與修正，持續迭代累積優勢。","水":"善流動整合資源，適應環境轉向。","火":"爆發推進與點燃氛圍，但需控溫。","土":"築基穩盤、抗壓承載，是長線支撐。","未知":""}; const tone=toneMap[el]||""; const catsSummary=Object.entries(ssCats).filter(([,v])=>v.length).map(([c,v])=>`${c}:${v.map(x=>x.name).join("、")}`).join("；")||"普通配置"; return `${name} 的${army}【${pillar}｜${ny}】${statusTxt}。${catsSummary}。${tone}`; }
export function classifyShenSha(pillars){ const branches=[pillars.Y[1],pillars.M[1],pillars.D[1],pillars.H[1]]; const mapPillarByBranch={}; const pillarKeyMap={Y:"年",M:"月",D:"日",H:"時"}; for(const k of ["Y","M","D","H"]){ const b=pillars[k][1]; if(!mapPillarByBranch[b]) mapPillarByBranch[b]=[]; mapPillarByBranch[b].push(pillarKeyMap[k]); } const ctx={ dayStem:pillars.D[0], dayBranch:pillars.D[1], yearBranch:pillars.Y[1], branches, pillarsByBranch:(b)=>mapPillarByBranch[b]||[] }; const hits=[]; for(const rule of ShenShaRules){ let src=[]; try{ const result=rule.rule({ dayStem:ctx.dayStem, dayBranch:ctx.dayBranch, yearBranch:ctx.yearBranch, branches:ctx.branches, pillarsByBranch:(bb)=>mapPillarByBranch[bb]||[] }); if(result&&result.length) src=result; }catch(e){} if(src.length){ hits.push({name:rule.name,cat:rule.cat,sources:src}); } } const cats={}; for(const h of hits){ if(!cats[h.cat]) cats[h.cat]=[]; cats[h.cat].push(h); } return { list:hits, cats }; }